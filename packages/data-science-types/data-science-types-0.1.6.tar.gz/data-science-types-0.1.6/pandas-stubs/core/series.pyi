from typing import List, Tuple, Type, Union, overload, Optional, Dict, TypeVar, Iterator, Generic
from typing_extensions import Literal
import numpy as _np

from pandas.core.indexing import _LocIndexer, _iLocIndexer

from pandas.core.frame import DataFrame
from .indexes import Index

class dtype: ...

_DType = TypeVar("_DType", bound=Union[_dtype, int, float, object])
_DType2 = TypeVar("_DType2", bound=Union[_dtype, int, float, object])
_ListLike = Union[_np.ndarray[_DType], List[_DType], Dict[str, _np.ndarray[_DType]]]
_Num = TypeVar("_Num", int, float, bool)

class Series(Generic[_DType]):
    def __init__(
        self,
        data: Optional[Union[_ListLike[_DType], Series[_DType]]],
        index: Union[str, int, Series] = ...,
    ): ...
    # magic methods
    def __and__(self, other: Series) -> Series: ...
    def __eq__(self, other: object) -> Series: ...
    def __ge__(self, other: float) -> Series: ...
    def __gt__(self, other: float) -> Series: ...
    def __le__(self, other: float) -> Series: ...
    def __lt__(self, other: float) -> Series: ...
    def __ne__(self, other: object) -> Series: ...
    def __mul__(self, other: float) -> Series: ...
    @overload
    def __getitem__(self, idx: Union[List[str], Index[int], Series, slice]) -> Series: ...
    @overload
    def __getitem__(self, idx: int) -> float: ...
    def __iter__(self) -> Iterator[_DType]: ...
    def __truediv__(self, other: object) -> Series: ...
    #
    # properties
    @property
    def iloc(self) -> _iLocIndexer: ...
    @property
    def index(self) -> Index[_DType]: ...
    @property
    def item(self) -> _DType: ...
    @property
    def loc(self) -> _LocIndexer: ...
    @property
    def shape(self) -> Tuple[int, ...]: ...
    @property
    def values(self) -> _np.ndarray: ...
    #
    # methods
    def all(self, axis: int = ..., bool_only: bool = ...) -> bool: ...
    def corr(
        self, other: Series, method: Literal["pearson", "kendall", "spearman"] = ...
    ) -> float: ...
    def count(self) -> int: ...
    def isnull(self) -> Series: ...
    def max(self) -> float: ...
    def mean(self) -> float: ...
    def median(self) -> float: ...
    def min(self) -> float: ...
    def mode(self) -> Series: ...
    def notnull(self) -> Series: ...
    def nunique(self) -> int: ...
    def replace(self, to_replace: int, value: int, inplace: bool) -> None: ...
    def std(self) -> float: ...
    def sum(self) -> float: ...
    def to_dict(self) -> Dict[Union[int, str], _DType]: ...
    @overload
    def to_numpy(self) -> _np.ndarray: ...
    @overload
    def to_numpy(self, dtype: Type[_Num]) -> _np.ndarray[_Num]: ...
    def unique(self) -> _np.ndarray[_DType]: ...
    def update(self, other: Series) -> None: ...
    def value_counts(self, normalize: bool = False) -> Series: ...
