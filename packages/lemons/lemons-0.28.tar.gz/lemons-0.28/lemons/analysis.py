#####################################################################################################
#################                            CSV-RELATED                            #################
#####################################################################################################

def read_csv(filepath, columns, sort=False, condense=True):
    """Reads the user-specified columns from a given .csv file.

    Args:
        filepath (str): The filepath to the .csv file.
        columns (list): A list of columns to store. Items must be integers.

    Kwargs:
        sort (bool, False): Whether or not to sort the columns list.
        condense (bool, True): Whether or not to remove duplicates from the
            columns list.

    Returns:
        A list of lists, where each nested list is one of the columns of data
        that was designated by the user for gathering.

    Raises:
        ValueError: If there are any items in the columns list that are not
            integers.

    """

    # Verify that each item of the columns list is an integer
    for column in columns:
        if type(column) != int:
            column_string = str(column) if type(column) == float else ( '\'' + str(column) + '\'' )
            message = column_string + ' is not an integer, so it cannot be used as a column index.'
            raise ValueError(message)

    # Import relevant packages
    import csv
    from collections import OrderedDict

    # Remove duplicates if desired
    if condense:
        columns = list(OrderedDict.fromkeys(columns))

    # Sort if desired
    if sort:
        columns.sort()

    # Create a list with a sublist for each column
    data = []
    [data.append([]) for i in range(len(columns))]

    # Iterate through the .csv file and add them to the appropriate sublist
    reader = csv.reader(open(filepath, 'r'), delimiter=',')
    for row in reader:
        for i, item in enumerate(row, start=1):
            for c, column in enumerate(columns, start=0):
                if i == column:
                    try:
                        data[c].append(float(item) if ('.' in item) else int(item))
                    except:
                        data[c].append(item if item else None)

    # Return the relevant information as a list of lists
    return data


def write_csv(filepath, data):
    """Writes a list of lists to a .csv file.

    Args:
        filepath (str):  Where to create the .csv file.
        data (list): The list of lists to write to the .csv file.

    """

    # Import relevant packages
    import csv

    # Get the length of the longest list and its index
    index = None
    longest = None
    for i, sublist in enumerate(data):
        length = len(sublist)
        if ( not index ) or ( length > longest ):
            index = i
            longest = length

    # Initialize the write list
    write = [[] for i in range(longest)]

    # Add data to the write list
    for i in range(longest):
        for sublist in data:
            write[i].append(sublist[i])

    # Write the data to specified filepath
    with open(filepath, 'w', newline='') as file:
        writer = csv.writer(file, delimiter=',')
        writer.writerows(write)


def separate_data(data, header_rows=None):
    """Separates header and body data into separate lists.


    Separates data in the form of a list of lists into header and body data.
    This function was written with the assumption that the data was generated
    by the read_csv function.

    Args:
        data (list): The list of lists to separate.

    Kwargs:
        header_rows (int, None): The number of header rows in the data.

    Returns:
        A tuple containing two lists of lists. The first list of lists is the
        header data, the second list of lists is the body data.

    """

    header, body = [], []
    if header_rows is not None:
        for c in range(len(data)):
            header.append( data[c][0:header_rows] )
            body.append( data[c][header_rows:] )
    else: body = data

    return header, body


def combine_data(header, body):
    """Combines header and body information.

    Combines header and body information into data in the form of a list of
    lists. This function was written with the assumption that the header and
    body data were generated by the separate_data function.

    Args:
        header (list): The list of lists containing the header data.
        body (list): The list of lists containing body data.

    Returns:
        A list of lists containing the combined data.

    """

    # Concatenate each header to its respective body data
    return [( header[c] + body[c] ) for c in range(len(header))]


#####################################################################################################
#################                           DATA ANALYSIS                           #################
#####################################################################################################

def tolerance_bands(data, resolution, mode='=', tolerance=0, lag=0):
    """Generates tolerances bands for a given dataset.

    Only works when the data has a constant resolution (a.k.a. a constant
    difference between independent variable data points).

    Args:
        data (list): The list of data points that the bands will be based on.
        resolution (float): The time/difference between independent variable
            data points.

    Kwargs:
        mode (str, '='): Which tolerance band(s) to generate.
            '=' --> Generates both the upper and low tolerance bands.
            '+' --> Generates only the upper tolerance band.
            '-' --> Generates only the lower tolerance band.
        tolerance (float, 0): Vertical tolerance.
        lag (float, 0): Horizontal tolerance.

    Returns:
        List of tolerance band data if mode is '+' or '-'.

        Tuple of two lists if mode is '='. First list if the upper band, second
        is the lower band.

    """

    def band(mode):
        i = 0
        band = []
        for c in data:
            if i >= lookback:
                if mode == '+':
                    # Get the maximum value in the lookback range and add tolerance
                    maximum = max(data[i-lookback:i+1])
                    toleranced = maximum + tolerance
                elif mode == '-':
                    # Get the minimum value in the lookback range and subtract tolerance
                    minimum = min(data[i-lookback:i+1])
                    toleranced = minimum - tolerance
                band.append(toleranced)
            else:
                # Don't want to plot any values before a lookback can be done
                band.append(None)
            i += 1
        return band

    lookback = round(lag / resolution)

    if mode == '+':
        return band(mode=mode)
    elif mode == '-':
        return band(mode=mode)
    elif mode == '=':
        return band(mode='+'), band(mode='-')
