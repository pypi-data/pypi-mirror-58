"""

Registry objects map types to codec objects that serialize and deserialize.
This

A 'codec' for the purposes of this module is anything that has:
 a pack method that takes an object of a type and returns bytes
 an unpack method that takes bytes and returns an object

Default types and codecs are autogenerated as namedtuples and structs.
The register method is used to do that, but it can also take other arguments.

You can write codec objects, or have classes implement pack and unpack methods.
Duck typing checks are the only king performed, so you have a lot of freedom.

"""
from struct import Struct
from collections import namedtuple
from .stream import Stream


def _attr_is_callable(obj, attr_name: str) -> bool:
    """
    Checks if the attribute named is callable.

    This means that non-function objects can be used.

    :param obj: any object
    :param attr_name: the name of the attribute to check.
    :return: true if the named attribute is callable
    """
    return (
            hasattr(obj, attr_name)
            and hasattr(getattr(obj, attr_name), "__call__")
    )


def _is_valid_codec(obj) -> bool:
    """
    Check whether pack and unpack attributes exist and are callable

    :param obj: any object to be checked
    :return: true if both attributes are callable
    """
    return (
        _attr_is_callable(obj, "pack") and
        _attr_is_callable(obj, "unpack")
    )


def struct_from_kwargs(arg_dict : dict, endian=None) -> Struct:
    """

    Generates a Struct object

    :param arg_dict: a dict of field -> struct flags
    :return: a Struct object
    """
    codec_components = []
    if endian is not None:
        codec_components.append(endian)

    codec_components += [value for key, value in arg_dict.items()]

    return Struct(''.join(codec_components))


class StructCodec:
    """
    Wraps generated struct objects to simplify pack/unpack.

    Limits the definition of a codec to pack(obj) or unpack(obj).
    If this weren't the case, logic would be  bit more complicated.

    User defined codecs should implement similar pack and unpack methods.

    """

    def __init__(self, cls: type, struct: Struct):
        """

        :param struct: the packer for the struct
        :param cls:
        """
        self.struct = struct
        self.cls = cls

    def pack(self, _tuple):
        return self.struct.pack(*_tuple)

    def unpack(self, raw_data):
        return self.cls._make(self.struct.unpack(raw_data))

    @property
    def size(self):
        return self.struct.size


class Registry:
    """
    Maps structs to
    """
    def __init__(self):
        self.type_to_codec = {}


    def register(self, cls, codec=None, **kwargs) -> type:
        """

        register(str, **kwargs):
            a storage codec is auto-generated using a Struct

        register(type):
            the passed implements pack and unpack methods

        register(type, codec):
            codec is an object that provides pack & unpack methods


        :param args:
        :param kwargs:
        :return:
        """

        if isinstance(cls, str):

            endian = kwargs.pop('endian', None)
            cls = namedtuple(cls, kwargs.keys())

            if codec is None:
                codec = StructCodec(cls, struct_from_kwargs(kwargs, endian))

        elif not isinstance(cls, type):
            raise TypeError(
                "First argument to register() must be a string or a type")

        if codec is None and len(kwargs) == 0:
            if not _is_valid_codec(cls):
                raise TypeError(
                    "Classes passed alone must have callable"
                    "pack and unpack attributes")
            codec = cls

        elif not _is_valid_codec(codec):
            raise TypeError("Codec objects must have callable pack and unpack attributes")

        self.type_to_codec[cls] = codec

        return cls


    def __getitem__(self, key):
        if not isinstance(key, type):
            raise ValueError("Only types can be passed to")

        if key not in self.type_to_codec:
            raise KeyError(f"Type {str(key)} not found in Registry")

        return self.type_to_codec[key]


    def Stream(self, base, mode=None):
        """

        Returns a Stream object, breaks PEP-8 intentionally as it wraps a class

        :param base:
        :param mode:
        :return:
        """
        return Stream(base, mode, registry=self)