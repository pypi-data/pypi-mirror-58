<h1>authprogs(1) -- SSH command authenticator</h1>
<h2>SYNOPSIS</h2>
<p><code>authprogs --run [options]</code></p>
<p><code>authprogs --install_key  [options]</code></p>
<p><code>authprogs --dump_config  [options]</code></p>
<p><code>authprogs --help</code></p>
<h2>DESCRIPTION</h2>
<p><code>authprogs</code> is an SSH command authenticator. It is invoked on
an ssh server and decides if the command requested by the
ssh client should be run or rejected based on logic in the <code>authprogs</code>
configuration file.</p>
<p>Passwordless SSH using ssh identies or pubkeys can enable all
sorts of wonderful automation, for example running unattended
batch jobs, slurping down backups, or pushing out code.
Unfortunately a key, once trusted, is allowed by default to run
anything on that system, not just the small set of commands you
actually need. If the key is compromised, you are at risk of a
security breach. This could be catastrophic, for example if the
access is to the root account.</p>
<p>Authprogs is run on the SSH server and compares the requested
command against the <code>authprogs</code> configuration file/files. This
enables <code>authprogs</code> to make intelligent decisions based on things
such as the command itself, the SSH key that was used, the
client IP, and such.</p>
<p><code>authprogs</code> is enabled by using the <code>command=</code> option in the
<code>authorized_keys</code> file.</p>
<h2>KEY INSTALLATION</h2>
<p>You can install your ssh identities/pubkeys manually, or allow authprogs to do the work for you.</p>
<h2>MANUAL KEY INSTALLATION</h2>
<p>You need to set up your <code>~/.ssh/authorized_keys</code> file to force
invocation of authprogs for the key or keys you wish to protect.</p>
<p>A line of an unrestricted <code>authorized_key</code> entry might look like this:</p>
<pre><code>ssh-rsa AAAAB3NzaC1yc2E.....OgQ7Pm1X8= user@example.com
</code></pre>
<p>When setting up this key to use authprogs, you add a <code>command=</code> option
to the very beginning of that line that points to the location where
authprogs lives. For example if authprogs is in /usr/bin/authprogs,
you would use this:</p>
<pre><code>command="/usr/bin/authprogs --run" ssh-rsa AAAAB3NzaC1yc2E.....OgQ7Pm1X8= user@example.com
</code></pre>
<p>You must include <code>--run</code> to let authprogs know it is running in SSH command mode.</p>
<p>Authprogs has other commandline options you may wish to include
as well, for example</p>
<pre><code>command="/usr/bin/authprogs --keyname=backups --run" ssh-rsa AAAA...Pm1X8= user@example.com
</code></pre>
<p>Lastly, if you wish, ssh offers a number of other helpful
restrictions you may wish to include that are separate from
authprogs. These can be appended right after (or before) the
command="" section if you wish.</p>
<pre><code>command="/usr/bin/authprogs --run",no-port-forwarding,no-pty ssh-rsa AAAA..Pm1X8= user@example.com
</code></pre>
<p>See the sshd(8) man page for more information about allowed
<code>authorized_keys</code> configuration options.</p>
<h2>AUTOMATED KEY INSTALLATION</h2>
<p>Authprogs is capable of adding your key to your <code>authorized_keys</code>
file (<code>~/.ssh/authorized_keys</code> by default) programatically. It
also disableds ssh port forwarding by default for this key (a
sensible default for most batch jobs.)</p>
<p>authprogs will refuse to install a key that is already present
in the <code>authorized_keys</code> file.</p>
<p>For example the following</p>
<pre><code>authprogs --install_key /path/to/backups_key.pub --keyname=backups
</code></pre>
<p>would cause the following line to be added to your
<code>~/.ssh/authorized_keys</code> file:</p>
<pre><code>command="/usr/bin/authprogs --keyname backups --run",no-port-forwarding ssh-rsa AAAA..Pm1X8= user@example.com
</code></pre>
<h2>RUN MODE OPTIONS</h2>
<p>Authprogs can run in several modes, depending on which of these
command line switches you provide.</p>
<ul>
<li>
<p><code>--run</code>:
   Act in run mode, as from an <code>authorized_keys</code> file.</p>
</li>
<li>
<p><code>--install_key filename</code>:
  Install the key contained in the named file into your <code>authorized_keys</code> file.</p>
</li>
<li>
<p><code>--dump_config</code>:
  Dump the configuration in a python-style view. Helpful only for debugging.</p>
</li>
<li>
<p><code>--help</code>:
  Show help information</p>
</li>
</ul>
<h2>OTHER OPTIONS</h2>
<p>The folowing options may apply to multiple run modes, as appropriate.</p>
<ul>
<li>
<p><code>--keyname key_name</code>:
    This option 'names' the key, for help in
    crafting your rules. Since an account may have multiple keys
    allowed, this helps us differentiate which one was used so we
    can make sensible choices.</p>
<p>In run mode, this specifies which name is used when
matching in the configuration, e.g.</p>
<pre><code>command="/usr/bin/authprogs --keyname backups --run" ...
</code></pre>
<p>In key installation mode, this adds the <code>--keyname</code> option to
the <code>authorized_keys</code> entry.</p>
<p><code>key_name</code> may contain no whitespace.</p>
</li>
<li>
<p><code>--configfile</code>:
    Specifies the authprogs configuration file to read.
    Defaults to <code>~/.ssh/authprogs.yaml</code>.</p>
<p>In key installation mode, this adds the <code>--configfile</code>
option to the <code>authorized_keys</code> entry.</p>
</li>
<li>
<p><code>--configdir</code>:
     Specifies the authprogs configuration, in which
     multiple configuration files can be found.
     Defaults to <code>~/.ssh/authprogs.d</code> if present.</p>
<p>Files in the configuration directory are read
 as rules in filename order. See CONFIGURATION
 for more info.</p>
</li>
</ul>
<h2>LIMITATIONS</h2>
<p>Commands are executed via fork/exec, and are not processed through
the shell. This means you cannot have multiple commands separated
by semicolons, pipelines, redirections, backticks, shell builtins,
wildcards, variables, etc.</p>
<p>Also, you cannot have spaces in any arguments your command runs.
This is because the SSH server takes the command that was specified
by the client and squashes it into the <code>SSH_ORIGINAL_COMMAND</code>
variable. By doing this it makes it impossible for us to know
what spaces in <code>SSH_ORIGINAL_COMAND</code> were between arguments and which
were part of arguments.</p>
<p>Here are some commands that would not work through authprogs:</p>
<ul>
<li><code>ssh host "rm /tmp/foo; touch /tmp/success"</code></li>
<li><code>ssh host "rm /tmp/*.html"</code></li>
<li><code>ssh host "cut -d: -f 1 /etc/passwd &gt; /tmp/users"</code></li>
<li><code>ssh host "touch '/tmp/file with spaces'"</code></li>
<li><code>ssh host "for file in /tmp/*.html; do w3m -dump $file &gt; $file.txt; done"</code></li>
</ul>
<p>You can work around these limitations by writing a shell script that
does what you need and calling that from authprogs, rather than attempting
to run complicated commandlines via ssh directly.</p>
<h2>CONFIGURATION FILES</h2>
<p>authprogs rules are maintained in one or more configuration files
in YAML format. </p>
<p>The rules allow you to decide whether the client's command should be run
based on criteria such as the command itself, the client IP address, and
ssh key in use.</p>
<p>Rules can be read from a single file (<code>~/.ssh/authprogs.yaml</code> by default)
or by putting files in a configuration directory (<code>~/.ssh/authprogs.d</code>).
The configuration directory method is most useful when
you want to be able to easily add or remove rules without manually
editing a single configuration file, such as when installing rules
via your configuration tool of choice.</p>
<p>All the authprogs configuration files are concatenated
together into one large yaml document which is then processed.
The files are concatenated in the following order:</p>
<ul>
<li><code>~/.ssh/authprogs.yaml</code>, if present</li>
<li>files in <code>~/.ssh/authprogs.d/</code> directory, in asciibetical order</li>
</ul>
<p>Dotfiles contained in a configuration directory are ignored.
The configuration directory is not recursed; only those files directly
contained are processed.</p>
<p>Each rule in the configuration file/files is tested in order and once
a match is found, processing stops and the command is run.</p>
<p>Rules are made of rule selection options (e.g. client IP address)
and subrules (e.g. a list of allowed commands). All pieces must
match for the command to be run.</p>
<p>The general format of a rule is as follows:</p>
<pre><code># First rule
-
  # Selection options
  #
  # All must match or we stop processing this rule.
  selection_option_1: value
  selection_option_2: value

  # The allow block, aka subrules
  #
  # This lets us group a bunch of possible commands
  # into one rule. Otherwise we'd need a bunch of
  # rules where you repeat selection options.

  allow:
    -
      rule_type: value
      rule_param_1: value
      rule_param_2: value
    -
      rule_type: value2
      rule_param_1: value
      rule_param_2: value

# Next rule
-
  selection_option_3: value
...
</code></pre>
<p>Some of the keys take single arguments, while others may take lists.
See the definition of each to understand the values it accepts.</p>
<h2>RULE SELECTION OPTIONS</h2>
<p>These configuration options apply to the entire rule, and help
you limit under what conditions the rule matches.</p>
<ul>
<li>from: This is a single value or list of values that define what SSH client
IP addresses are allowed to match this rule. The client IP address
is gleaned by environment variables set by the SSH server. Any from value
may be an IP address or a CIDR network.</li>
</ul>
<p>Examples:</p>
<pre><code>-
  from: 192.168.1.5
  ...

-
  from: [192.168.0.1, 10.0.0.3]
  ...

-
  from:
    - 192.168.0.0/24
    - 10.10.0.3
  ...
</code></pre>
<ul>
<li>keynames:  This is a single value or list of values that define which
SSH pubkeys are allowed to match this rule.  The keyname
is specified by the <code>--keyname foo</code> parameter in the
authprogs command line in the entry in <code>authorized_keys</code>.</li>
</ul>
<p>Examples:</p>
<pre><code>-
  keynames: backups
  ...

-
  keynames: [repo_push, repo_pull]
  ...

-
  keynames:
    - repo_push
    - repo_pull
  ...
</code></pre>
<h2>ALLOW SUBRULE SECTION</h2>
<p>The allow section of a rule is a single subrule or list of subrules.</p>
<p>Subrules can be simple, for example the explicit command match, or be
more program-aware such as scp support. You specify which kind of
subrule you want with the <code>rule_type</code> option:</p>
<pre><code>-
  allow:
    -
      rule_type: command
      command: /bin/touch /tmp/timestamp
    -
      command: /bin/rm /tmp/bar
    -
      rule_type: scp
      allow_upload: true
...
</code></pre>
<p>See the separate subrules sections below for how to craft each type.</p>
<h2>COMMAND SUBRULES</h2>
<p>This section applies if <code>rule_type</code> is set to <code>command</code> or is not
present at all.</p>
<p>The command requested by the client is compared to the command
listed in the rule. (Spaces are squashed together.) If it matches,
then the command is run.</p>
<p>Note that the command must be <em>exactly</em> the same; authprogs is not
aware of arguments supported by a comamnd, so it cannot realize that
<code>"ls -la"</code> and <code>"ls -a -l"</code> and <code>"ls -al"</code> and <code>"ls -l -a"</code> are all the
same. You can list multiple commands to allow you to accept
variants of a command if necessary.</p>
<p>The simplest configuration looks like this:</p>
<pre><code>-
  allow:
    command: /bin/true
</code></pre>
<p>Or you can provide a list of commands:</p>
<pre><code>-
  allow:
    - command: /bin/true
    - command: /bin/false
</code></pre>
<p>A number of optional settings can tweak how command matching
is performed.</p>
<ul>
<li>
<p><code>allow_trailing_args: true</code>:  This setting allows you to specify a
    partial command that will match as long as the command requested
    by the client is the same or longer.  This allows you to avoid
    listing every variant of a command that the client may wish to run.</p>
<p>Examples:</p>
<p>-
    allow:
      -
        command: /bin/echo
        allow_trailing_args: true
      -
        command: /bin/ls
        allow_trailing_args: true
      -
        command: /bin/rm -i
        allow_trailing_args: true</p>
</li>
<li>
<p><code>pcre_match: true</code>:  Compare the command using pcre regular expressions,
    rather than doing an explicit match character by character. The regex
    is <em>not</em> anchored at the beginning nor end of the string, so if you
    wish to anchor it is your responsibility to do so.</p>
<p>Caution: never underestimate the sneakiness of an adversary who
may find a way to match your regex and still do something
nasty.</p>
<p>Examples:</p>
<p>-
    allow:
      -
        # Touch the foo file, allowing any
        # optional command line params
        # before the filename</p>
<pre><code>    command: ^touch\\s+(-\\S+\\s+)*foo$
    pcre_match: true
  -
    # attempt to allow rm of files in /var/tmp
    # but actually would fail to catch malicious
    # commands e.g. /var/tmp/../../etc/passwd
    #
    # As I said, be careful with pcre matching!!!

    command: ^/bin/rm\\s+(-\\S+\\s+)*/var/tmp/\\S*$
    pcre_match: true
</code></pre>
</li>
</ul>
<h2>SCP SUBRULES</h2>
<p>authprogs has special support for scp file transfer. You are not
required to use this - you could use a simple command subrules
to match explicit scp commands - but using an scp-specific
subrule offers you greater flexibility.</p>
<p>To trigger scp mode, use <code>rule_type: scp</code>.</p>
<p>The scp options are as follows.</p>
<ul>
<li>
<p><code>rule_type: scp</code>: This indicates that this is an scp subrule.</p>
</li>
<li>
<p><code>allow_upload: true|false</code>:    Allow files to be uploaded to the ssh
server. Defaults to false.</p>
</li>
<li>
<p><code>allow_download: true|false</code>:  Allow files to be downloaded from the
ssh server. Defaults to false.</p>
</li>
<li>
<p><code>allow_recursion: true|false</code>:  Allow recursive (-r) file up/download.
Defaults to false.</p>
</li>
<li>
<p><code>allow_permissions: true|false</code>:  Allow scp to get/set the permissions
of the file/files being transfered.  Defaults to false.</p>
</li>
<li>
<p><code>files</code>:  The files option allows you to specify which file or files are
allowed to be tranfered. If this is not specified then transfers are
not restricted based on filename.</p>
<p>Examples:</p>
<p>-
    allow:
      - rule_type: scp
        allow_download: true
        files:
          - /etc/group
          - /etc/passwd
      - rule_type: scp
        allow_upload: true
        files: [/tmp/file1, /tmp/file2]</p>
</li>
</ul>
<h2>EXAMPLES</h2>
<p>Here is a sample configuration file with multiple rules,
going from simple to more complex.</p>
<p>Note that this config can be spread around between the
<code>~/.ssh/authprogs.yaml</code> and <code>~/.ssh/authprogs.d</code> directory.</p>
<pre><code># All files should start with an initial solo dash -
# remember, we're being concatenated with all other
# files!

# Simple commands, no IP restrictions.
-
  allow:
    - command: /bin/tar czvf /backups/www.tgz /var/www/
    - command: /usr/bin/touch /var/www/.backups.complete

# Similar, but with IP restrictions
-
  from: [192.168.0.10, 192.168.0.15, 172.16.3.3]
  allow:
    - command: git --git-dir=/var/repos/foo/.git pull
    - command: sudo /etc/init.d/apache2 restart

# Some more complicated subrules
-
  # All of these 'allows' have the same 'from' restrictions
  from:
    - 10.1.1.20
    - 10.1.1.21
    - 10.1.1.22
    - 10.1.1.23
  allow:
    # Allow unrestricted ls
    - command: /bin/ls
      allow_trailing_args: true

    # Allow any 'service apache2 (start|stop)' commands via sudo
    - command: sudo service apache2
      allow_trailing_args:true

    # How about a regex? Allow wget of any https url, outputting
    #  to /tmp/latest
    - command: ^/usr/bin/wget\\s+https://\\S+\\s+-O\\s+/tmp/latest$
      pcre_match: true

    # Allow some specific file uploads
    - rule_type: scp
      allow_upload: true
      files:
        - /srv/backups/host1.tgz
        - /srv/backups/host2.tgz
        - /srv/backups/host3.tgz
</code></pre>
<h2>TROUBLESHOOTING</h2>
<p><code>--dump_config</code> is your friend. If your yaml config isn't parsing,
consider <code>--dump_config --logfile=/dev/tty</code> for more debug output
to find the error.</p>
<h2>FILES</h2>
<ul>
<li>
<p><code>~/.ssh/authorized_keys</code>: The default place your key should be installed
    and configured to call authprogs. The actual
    location can differ if your administrator
    has changed it.</p>
</li>
<li>
<p><code>~/.ssh/authprogs.yaml</code>: Default authprogs configuration file. Override with --configfile.</p>
</li>
<li>
<p><code>~/.ssh/authprogs.d</code>: Default authprogs configuration directory. Override with --configdir.</p>
</li>
</ul>
<h2>ENVIRONMENT</h2>
<p>authprogs uses the following environment variables that are set
by the sshd(8) binary:</p>
<ul>
<li>
<p><code>SSH_CONNECTION</code>: This is used to determine the client IP address.</p>
</li>
<li>
<p><code>SSH_CLIENT</code>: This is used to determine the client IP address
    if SSH_CONNECTION was not present.</p>
</li>
<li>
<p><code>SSH_ORIGINAL_COMMAND</code>: The (squashed) original SSH command that was issued by the client.</p>
</li>
</ul>
<p>authprogs sets the following environment variables for use by the
authenticated process</p>
<ul>
<li><code>AUTHPROGS_KEYNAME</code>: the value of the --keyname command line. Will be set to an empty string if no --keyname was set.</li>
</ul>
<h2>EXIT STATUS</h2>
<p>authprogs returns 0 on success, non-zero on errors. In run mode it exits with
the exit code of the command that was requested, or 126 on unexpected errors.</p>
<h2>LOGGING AND DEBUGGING</h2>
<p>If a <code>--logfile</code> is specified then it will be opened in append
mode and a line about each command that is attempted to be run
will be written to it. The line itself is in the form of a python
dictionary.</p>
<p>If authprogs is run with <code>--debug</code>, then this logfile will get increased
debugging information, including the configuration, rule matching status
as they are checked, etc.</p>
<h2>HISTORY</h2>
<p>A perl version of authprogs was originally published
at http://www.hackinglinuxexposed.com/articles/20030115.html
in 2003. This is a complete rewrite in python, with a more
extensible configuration, and avoiding some of the limitations
of the former.</p>
<h2>SEE ALSO</h2>
<p>ssh(1), sshd(8), scp(1).</p>
<h2>AUTHOR</h2>
<p>Bri Hatch <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#114;&#105;&#64;&#105;&#102;&#111;&#107;&#114;&#46;&#111;&#114;&#103;">&#98;&#114;&#105;&#64;&#105;&#102;&#111;&#107;&#114;&#46;&#111;&#114;&#103;</a></p>