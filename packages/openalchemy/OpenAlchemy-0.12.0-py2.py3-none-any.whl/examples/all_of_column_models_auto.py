"""Autogenerated SQLAlchemy models based on OpenAlchemy models."""
# pylint: disable=no-member,useless-super-delegation

import typing

import sqlalchemy
from sqlalchemy import orm

from open_alchemy import models


class _EmployeeDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    id: int
    name: str
    division: "DivisionDict"


class EmployeeDict(_EmployeeDictBase, total=False):
    """TypedDict for properties that are not required."""

    salary: typing.Optional[float]


class Employee(models.Employee):  # type: ignore
    """SQLAlchemy model."""

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    name: str
    division: "Division"
    salary: typing.Optional[float]

    def __init__(
        self,
        id: int,
        name: str,
        division: "Division",
        salary: typing.Optional[float] = None,
    ) -> None:
        """Construct."""
        kwargs = {"id": id, "name": name, "division": division}
        if salary is not None:
            kwargs["salary"] = salary

        super().__init__(**kwargs)

    @classmethod
    def from_dict(
        cls,
        id: int,
        name: str,
        division: "DivisionDict",
        salary: typing.Optional[float] = None,
    ) -> "Employee":
        """Construct from a dictionary (eg. a POST payload)."""
        kwargs = {"id": id, "name": name, "division": division}
        if salary is not None:
            kwargs["salary"] = salary

        return super().from_dict(**kwargs)

    def to_dict(self) -> EmployeeDict:
        """Convert to a dictionary (eg. to send back for a GET request)."""
        return super().to_dict()


class DivisionDict(typing.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: int
    name: typing.Optional[str]


class Division(models.Division):  # type: ignore
    """SQLAlchemy model."""

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    name: typing.Optional[str]

    def __init__(
        self, id: typing.Optional[int] = None, name: typing.Optional[str] = None
    ) -> None:
        """Construct."""
        kwargs = {}
        if id is not None:
            kwargs["id"] = id
        if name is not None:
            kwargs["name"] = name

        super().__init__(**kwargs)

    @classmethod
    def from_dict(
        cls, id: typing.Optional[int] = None, name: typing.Optional[str] = None
    ) -> "Division":
        """Construct from a dictionary (eg. a POST payload)."""
        kwargs = {}
        if id is not None:
            kwargs["id"] = id
        if name is not None:
            kwargs["name"] = name

        return super().from_dict(**kwargs)

    def to_dict(self) -> DivisionDict:
        """Convert to a dictionary (eg. to send back for a GET request)."""
        return super().to_dict()
