#                                                       /`-
# _                                  _   _             /####`-
# | |                                | | (_)           /########`-
# | |_ _ __ __ _ _ __  ___  ___ _ __ | |_ _ ___       /###########`-
# | __| '__/ _` | '_ \/ __|/ _ \ '_ \| __| / __|   ____ -###########/
# | |_| | | (_| | | | \__ \  __/ | | | |_| \__ \  |    | `-#######/
# \__|_|  \__,_|_| |_|___/\___|_| |_|\__|_|___/  |____|    `- # /
#
# Copyright (c) 2019 transentis labs GmbH
# MIT License

###################
## SDModel Class ##
###################
# This is the main class for Python SD Models generated by the SD Compiler

# linear interpolation between a set of points
import numpy as np
from scipy.interpolate import interp1d
import re
import logging

def LERP(x,points):
    """
    Linear interpolation between a set of points
    :param x: x to obtain y for
    :param points: List of tuples containing the graphical function's points [(x,y),(x,y) ... ]
    :return: y value for x obtained using linear interpolation
    """
    x_vals = np.array([ x[0] for x in points])
    y_vals = np.array([x[1] for x in points])

    if x<= x_vals[0]:
        return y_vals[0]

    if x >= x_vals[len(x_vals)-1]:
        return y_vals[len(x_vals)-1]

    f = interp1d(x_vals, y_vals)
    return float(f(x))

class UnsupportedListIndexException(Exception):
    pass

def findListIndex(index):
    split_index = index.split(":")
    if len(split_index) == 2:
        return [x for x in range(int(split_index[0]), int(split_index[1]) + 1)]
    if len(split_index) > 2:
        logging.error("Multiple list indices are not supported! Indices: {}".format(index))
        raise UnsupportedListIndexException("Multiple list indices are not supported! Indices: {}".format(index))
    return split_index

class SDModel():
    def find_dimensions(self, stock):
        stockdimensions = {}
        for dimension, values in self.dimensions.items():
            if stock in values["variables"]:
                stockdimensions[dimension] = values["labels"]

        if len(stockdimensions.keys()) == 1:
            return [stock + "[{}]".format(x) for x in stockdimensions[list(stockdimensions.keys())[0]]]

    def equation(self, equation, t):
        """
        This method is the API endpoint for all equations. It automatically extracts the indices for array access!
        :param equation:
        :param t:
        :return:
        """
        re_find_indices = r'\[([^)]+)\]'
        equation_raw = equation.split("[")[0]

        if "[*]" == equation[-3:]:
            return self.equations[equation[:-3]](t)

        if not "[" in equation:

            return self.memoize(equation,t)

        try:
            group = re.search(re_find_indices,equation).group(0).replace("[","").replace("]","")

            if group:
                indices = group.split(",")

                if len(indices) > 0:
                    result = 0
                    for index in indices:
                        list_index = findListIndex(index)
                        result += sum([self.equations[equation_raw + "[{}]".format(index)](t) for index in list_index])
                    return result
        except Exception as e:
            raise e
            #pass

        return self.memoize(equation,t)
    def memoize(self, equation, arg):
        mymemo = self.memo[equation]
        if arg in mymemo.keys():
            return mymemo[arg]
        else:
            result = self.equations[equation](arg)
            mymemo[arg] = result

        return result

    def __init__(self):
        # Simulation Buildins
        self.dt = 1
        self.starttime = 0
        self.stoptime = 0
        self.units = '1'
        self.method = 'None'

        self.equations = {}
        self.stocks = []

        self.flows = []
        self.converters = []
        self.gf = []
        self.constants = []
        self.events = []
        self.dimensions = {}

        self.memo = {}
        for key in list(self.equations.keys()):
            self.memo[key] = {}  # DICT OF DICTS!

    def setDT(self, v):
        self.dt = v

    def setStarttime(self, v):
        self.starttime = v

    def setStoptime(self, v):
        self.stoptime = v

    def specs(self):
        return self.starttime, self.stoptime, self.dt, self.units, self.method

