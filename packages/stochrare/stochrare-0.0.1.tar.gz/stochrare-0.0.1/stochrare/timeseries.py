"""
Tools for time series analysis.
These tools should apply in particular to trajectories generated by stochastic processes
using the dynamics subpackage.
"""
import numpy as np

def running_mean(x, N):
    """
    Return the running mean of a time series
    """
    cumsum = np.cumsum(np.insert(x, 0, 0))
    return (cumsum[N:] - cumsum[:-N]) / N

def transitionrate(x, threshold, **kwargs):
    """
    Count the number of times a given trajectory goes across a given threshold.
    A typical use case is to study transitions from one attractor to the other.

    x: the time series (a numpy array)
    threshold: the threshold (e.g. separating the two attractors); a float
    avg (optional): averaging window for smoothing timeseries before computing transition rate

    Without smoothing (avg=1), the result should coincide with the number of items in the generator
    levelscrossing(x,0) when starting with the right transition,
    or that number +1 if we use the wrong isign in levelscrossing.
    """
    window = kwargs.get('avg', 1)
    y = running_mean(x, window) if window > 1 else x
    return float(((y[1:]-threshold)*(y[:-1]-threshold) < 0).sum())/len(y)

def levelscrossing(x, threshold, **kwargs):
    """
    Maps the stochastic process x(t) onto a stochastic process {t_i}
    where the 't_i's correspond to crossing levels +- c
    """
    # By default we start by detecting the transition below the -c threshold
    sign = kwargs.get('isign', 1)
    if sign == 0:
        sign = 1
    if not abs(sign) == 1:
        sign /= abs(sign)
    for i in range(len(x)-1):
        if (threshold+sign*x[i]) > 0 and (threshold+sign*x[i+1]) < 0:
            sign *= -1
            yield i

def residencetimes(x, threshold):
    transtimes = np.array([t for t in levelscrossing(x, threshold)])
    return transtimes[1:]-transtimes[:-1]


def blockmaximum(traj, nblocks, mode='proba', modified=False, **kwargs):
    """
    Generate pairs (a, p(a)) (mode='proba') or (a, r(a)) (mode='returntime'),
    where p(a) is the probability to reach a and r(a) the corresponding return time (see below).

    Block maximum method.
    Given a timeseries X_t, we define the probability to reach a given threshold a over a time T:
    p(a) = Prob[max_{0 < t < T} X_t > a]
    Or equivalently, the return time of the even X_t > a: r(a)=T/p(a)

    To do so, we divide the input trajectory in same-size blocks and compute the maximum in each
    block. We sort the maxima in descending order and assign probability n/nblocks to the maximum
    of rank n: in the input timeseries, maximum n has been reached n times.

    Arguments
    - traj: the timeseries X_t
    - nblocks: the number of blocks. It should be chosen so that each block is larger than the
               correlation time of the timeseries, but we also want as many blocks as possible.
    - mode: 'proba' (default) or 'returntime': determine whether to return probability
            or return time of the event X_t > a.
    - modified: bool (default False)
                Use the modified version of the bock maximum estimator defined in
                Lestang, Ragone, Brehier, Herbert and Bouchet, J. Stat. Mech. 2018
    - time: ndarray
            sampling times (default is just 0,1,2,...)
    """
    time = kwargs.get('time', np.arange(len(traj)))
    trajlen = float(time[-1]-time[0])
    blocklen = int(len(traj)/nblocks)
    blockmax = [np.max(traj[k*blocklen:(k+1)*blocklen]) for k in range(nblocks)]
    last = 0 if modified else None
    for cnt, maxi in enumerate(np.sort(blockmax)[:last:-1], 1):
        if mode == 'proba':
            yield maxi, float(cnt)/float(nblocks)
        else:
            yield maxi, -trajlen/(nblocks*np.log(1-float(cnt)/nblocks)) if modified else trajlen/cnt
